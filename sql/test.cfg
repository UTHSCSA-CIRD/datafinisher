# we will be using the subsection custom method, so for now there is no [DEFAULT]
# section until we have some option we want to always be explicitly overriden,
# bypassing inheritance from the parent section 
# LSMM: Won't the system default to using the "unknown" set. Isn't that the same as a default?
# AFB: No, see below

# any section named [foo_bar] will attempt to inherit from a section named [foo]
# LSMM: foo is non-descriptive, it's recommended to use a real example like medication_info
# AFB: that is exactly the point-- when a behavior is fully general, one uses an obvious metasyntactic variable
# AFB: to avoid the reader being distracted by the context, and wondering which part is general and which tied
# AFB: to just that context
# and will add a `suffix` option that will be equal to _bar
# LSMM: a second column containing the elements listed in the _bar rule, right?
# AFB: No. Literally what it says: the [foo_bar] section will be read as if it contains a line saying
# AFB: `suffix = bar`
# if no [foo] section exists, it will inherit directly from [unknown]
# LSMM: this is acting as a default, so the top paragraph can be removed, right? 
# AFB: It is acting as a default, but not in the standard ConfigParser way. Anything placed in [DEFAULT]
# AFB: once it starts existsing again, will be read by both the standard methods of ConfigParser and by the
# AFB: custom methods I added on as literally existing in every section without the granular inheritance 
# AFB: mechanism I designed
# [foo] will also inherit from [unknown] in either case

# Do not modify this section. 
[unknown]
# LSMM: I'll look into how we can rename these variables. I don't think they will make any sense to the end user.
# AFB: s/end user/admin/
sub_slct_std = SELPATIENTDATE
# LSMM: I'll look into parsing this out, the user won't know what xgr stands for and it's not explained in the comments or readme
sub_payload = xgr(concept_cd,modifier_cd,instance_num,valtype_cd,tval_char,nval_num,valueflag_cd,quantity_num,units_cd,location_cd,confidence_num) {ccode} 
# LSMM: ccode?
# AFB: concept code
sbwr= 
# LSMM: Will look into what represents a null config option.
# AFB: it means the option gets set (and thus does not produce an error if retrieved) but to a blank value
sub_frm_std = from df_obsfact where id = {cid} 
# LSMM: from the end user perspective: What is df_obsfact and {cid}? They wouldn't know what to do with this without reading the code.
# AFB: Yes, this needs to be documented, but let's always remember these are not for end users, they are for admins
presuffix=
suffix=
sub_grp_std = group by pn,sd) {jcode} on {jcode}.pn = patient_num and {jcode}.sd = start_date 
# If concode = 1, that means the data element is broken out 
# into individual concept codes (e.g. labs)
# LSMM: Within the same column, in that json format?
# AFB: No, into separate self-joins.
# LSMM: End user will think: where is the other side of this parenthesis? 
# LSMM: This segment requires the user to know the sql statements datafinisher is creating in order to edit it.
# AFB: Agreed, and for now the most immediate solution is to document it, which we will
concode = 0
rule = UNKNOWN_DATA_ELEMENT
# LSMM: does the order of the config options matter? if not the rule should probably move up to the top
# AFB: it matters right now, should put in a ordering option so that it stops mattering
grouping = 1 
# LSMM: What are the options here? What does 1 mean?
# AFB: You're right, needs to be documentd
subgrouping = 9 
# LSMM: same as above
# AFB: you're right, needs to be documentd
in_use = 1
criterion =

# Modify the sections below to configure datafinisher for your site
# You may temporarily disable a rule by adding: "in_use = 0" to its configuration options. 

# It is recommended that you NOT modify this section as these rules should be applicable across most I2B2 sites.

[codemod]
sub_payload = dgr(concept_cd,modifier_cd) {ccode} 
# LSMM: User won't know what dgr means.
# AFB: Youre, right needs to be documented
rule = codemod
subgrouping = 1
criterion =  coalesce(tval_char,valueflag_cd,units_cd,confidence_num,quantity_num,location_cd,valtype_cd,nval_num,-1) = -1 and mod is not null 
# LSMM: same as dgr
# AFB: Youre, right needs to be documented

[codemod_info]
sub_payload = igr (NULL,NULL,instance_num,valtype_cd,tval_char,NULL,valueflag_cd,quantity_num,units_cd,location_cd,confidence_num) {ccode}
# LSMM: same as dgr
# AFB: you're right, needs to be documentd
subgrouping = 2

[code]
sub_payload = dgr(concept_cd,modifier_cd) {ccode}
# LSMM: this is the same dgr option from above, is dgr ever used with something other than concept_cd, modifier_cd) {ccode} ?
# AFB: Don't know yet. That's why we need to stay flexible. When we both have more experience in 
# AFB: the actual semantics of real live i2b2 sites, we'll be better positioned to decide how to simplify
# AFB: it without unintended consquences
rule = code
criterion = coalesce(mod,tval_char,valueflag_cd,units_cd,confidence_num,quantity_num,location_cd,valtype_cd,nval_num,-1) = -1 

# It is recommended that you modify this section to adjust datafinisher for your site. 

[diag]
sub_payload = dgr(concept_cd,modifier_cd) {ccode}
sbwr = and modifier_cd not in ('DiagObs:MEDICAL_HX','PROBLEM_STATUS_C:2','PROBLEM_STATUS_C:3')
rule = diag
criterion = ddomain like '%ICD9%DX_ID%' or ddomain like '%DX_ID%ICD9%' 
# LSMM: ddomain?
# AFB: Needs to be documented. Means data domain, i.e. the prefix part of the concept code

[diag_inactive]
sbwr =  and modifier_cd in ('DiagObs:MEDICAL_HX','PROBLEM_STATUS_C:2','PROBLEM_STATUS_C:3')
grouping = 2

[ethnicity]
sub_slct_std = SELPATIENT 
# LSMM: it looks like this could code for sub_grp_std...?
# AFB: Huh? No, I meant what I wrote, sub_grp_std is for grouping and the `ON` part of the join
# AFB: But, thanks for reminding me. There is another shortcut that is applicable here.
sub_payload = concept_cd {ccode}
sub_grp_std = GRPJPATIENT
rule = ethnicity
subgrouping = 1
criterion = ddomain like '%DEM|ETHNICITY%' 


[loinc]
sub_slct_std = SELDISTPATIENTDATE
sub_payload = avg(nval_num) {ccode}
sbwr = and concept_cd = {concept_cd}
presuffix = {concept_cd}
# we explicitly set a suffix here so that this sub-rule can still be the template 
# for loinc_unit and loinc_info
suffix = _num
concode = 1
rule = loinc
subgrouping = 1
criterion = ddomain like '%LOINC%COMPONENT_ID%' or ddomain like '%COMPONENT_ID%LOINC%' 

[loinc_unit]
sub_payload = group_concat(distinct lower(units_cd)) {ccode}
subgrouping = 2

[loinc_info]
sub_payload = igr(NULL,NULL,instance_num,valtype_cd,tval_char,NULL,valueflag_cd,quantity_num,NULL,location_cd,confidence_num) {ccode}
subgrouping = 3

[vitals]
sub_slct_std = SELDISTPATIENTDATE
sub_payload = avg(nval_num) {ccode}
# as with loinc, we explicitly set a suffix here so that this sub-rule can still 
# be the template for vitals_info
suffix = _num
rule = vitals
subgrouping = 1
criterion = ddomain like '%PAT_ENC%' and ddomain not like '%PAT_ENC:LMP%'

[vitals_info]
sub_payload = igr(NULL,NULL,instance_num,valtype_cd,tval_char,NULL,valueflag_cd,quantity_num,NULL,location_cd,confidence_num) {ccode}
subgrouping = 2

# LSMM: assuming from the test data that this section was for testing the config file...? Removed.
# AFB: was using this for my attempt at unit tests, but ah, can add back in later.