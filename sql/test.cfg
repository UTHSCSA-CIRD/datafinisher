#####CMH Ruleset


# Temporarily using custom subsection method [unknown], so for now there is no [DEFAULT]
# section until we have some option we want to always be explicitly overriden,
# bypassing inheritance from the parent section 


#/* 
#**To configure this file the table "df_dtdict" MUST be used! Make sure to generat this table prior to trying to alter #the config file. 
#Name of the rule

#[exampleRule]

##sub_slct_std may either be SELPATIENTDATE, SELPATIENT, or SELDISTPATIENTDATE depending on if the type of code 
##should be grouped by patient and date, patient only, or distinct patient and date <<LSMM: Note to Alex: isn't grouped 
##by patient and date the same as selecting distinct patient and date...? When would the patient/date not be distinct?>> 

#sub_slct_std = SELPATIENTDATE

#sub_paylod may be any of the following: 
## dgr(concept_cd, modifier_cd) {ccode} ((for existance- aimed at diagnosis and modifiers))
## xgr(concept_cd,modifier_cd,instance_num,valtype_cd,tval_char,nval_num,valueflag_cd,quantity_num,
#       units_cd,location_cd,confidence_num) {ccode} ((For unknown elements or when you simply want to capture   
#       everything.))
## concept_cd {ccode} --just the concept_cd defined in this field.
##<<LSMM: Note to Alex -- these should be in the same order as the columns in df_dtdict to make it easier for the user>>
## igr (concept_cd,modifier_cd,instance_num,valtype_cd,tval_char,nval_num,valueflag_cd,quantity_num,
#        units_cd,location_cd,confidence_num) {ccode} ((Similar to xgr, but allows you to place NULL in the columsn
#        you don't want represented. TIP: You can use df_dtdict to figure out if there are any values in those fields 
#	<<LSMM: not seeing that this is always the case: and the number of distinct value types.>>
## avg(nval_num) {ccode} -- averages together the values provided in the parameter field. Typically nval_num.


#sub_payload = dgr(concept_cd,modifier_cd) {ccode}

##rule- this is another name for your rule? <<LSMM: I'm guessing the core rule name that the subrules follow as well>>

#rule = meds

# criterion allows you to indicate which elements in df_dtdict belong to which rule. Write your rules to fit df_dtdict. 
#  utilizing either the ddomain or coalesce or some other form of sqlbased criteria. 

# IMPORTANT!!! Criterion must EXACTLY match the dictionary diffinition in df_dtdict!!! E.g. ddomain:  
#  "someStart,someOTHERstart" criterion = "ddomain like 'someOTHERstart%'" WILL NOT WORK!!! must have: "ddomain like 
#  '%someStart%' or ddomain like '%someOTHERstart%'" Or "ddoman = 'someStart,someOTHERstart'"

#criterion = ddomain like 'KUH|MEDICATION_ID%' or ddomain like 'RXCUI%' 
#*/

# Do not modify this section. 
[unknown]
sub_slct_std = SELPATIENTDATE
sub_payload = xgr(concept_cd,modifier_cd,instance_num,valtype_cd,tval_char,nval_num,valueflag_cd,quantity_num,units_cd,location_cd,confidence_num) {ccode} 
sbwr= 
sub_frm_std = from df_obsfact where id = {cid} 
presuffix=
suffix=
sub_grp_std = group by pn,sd) {jcode} on {jcode}.pn = patient_num and {jcode}.sd = start_date 
# If concode = 1, that means the data element is broken out 
# into individual concept codes (e.g. labs)
concode = 0
rule = UNKNOWN_DATA_ELEMENT
grouping = 1 
subgrouping = 9 
in_use = 1
criterion =

# Modify the sections below to configure datafinisher for your site
# You may temporarily disable a rule by adding: "in_use = 0" to its configuration options. 

# It is recommended that you modify this section to adjust datafinisher for your site. 

[diag]
sub_payload = dgr(concept_cd,modifier_cd) {ccode}
sbwr = and modifier_cd not in ('DiagObs:MEDICAL_HX','PROBLEM_STATUS_C:2','PROBLEM_STATUS_C:3')
rule = diag
criterion = ddomain = 'ICD9' 

[diag_inactive]
sbwr =  and modifier_cd in ('DiagObs:MEDICAL_HX','PROBLEM_STATUS_C:2','PROBLEM_STATUS_C:3')
grouping = 2

[loinc]
sub_slct_std = SELDISTPATIENTDATE
sub_payload = avg(nval_num) {ccode}
sbwr = and concept_cd = {concept_cd}
presuffix = {concept_cd}
# we explicitly set a suffix here so that this sub-rule can still be the template 
# for loinc_unit and loinc_info
suffix = _num
concode = 1
rule = loinc
subgrouping = 1
criterion = ddomain = 'LOINC'

[loinc_unit]
sub_payload = group_concat(distinct lower(units_cd)) {ccode}
subgrouping = 2

[loinc_info]
sub_payload = igr(NULL,NULL,NULL,valtype_cd,tval_char,nval_num,NULL,NULL,units_cd,location_cd,NULL) {ccode}
subgrouping = 3

[vitals]
sub_slct_std = SELDISTPATIENTDATE
sub_payload = avg(nval_num) {ccode}
# as with loinc, we explicitly set a suffix here so that this sub-rule can still 
# be the template for vitals_info
suffix = _num
rule = vitals
subgrouping = 1
criterion = ddomain = 'EC'

[vitals_info]
sub_payload = igr(concept_cd,NULL,NULL,valtype_cd,tval_char,nval_num,valueflag_cd,quantity_num,
        units_cd,location_cd,NULL) {ccode}
subgrouping = 2

[medication]
sub_slct_std = SELPATIENTDATE
sub_payload = dgr(concept_cd,modifier_cd) {ccode}
rule = meds
criterion = ddomain = 'NDC' 
